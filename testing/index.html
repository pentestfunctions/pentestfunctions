<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Scanner</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        h1 {
            color: #4CAF50;
        }
        #progress-container {
            margin-bottom: 10px;
            background-color: #f3f3f3;
            border: 1px solid #ccc;
            height: 20px;
            width: 100%;
        }
        #progress-bar {
            background-color: #4caf50;
            height: 100%;
            width: 0;
            text-align: center;
            color: white;
        }
        #results {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #ddd;
            background-color: #ffffff;
            max-height: 300px;
            overflow-y: auto;
        }
        #info {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #ddd;
            background-color: #ffffff;
        }
        #info h2 {
            margin: 0;
            font-size: 1.2em;
        }
    </style>
</head>
<body>
    <h1>Network Scanner</h1>

    <div id="info">
        <h2>Your Information:</h2>
        <p><strong>Public IP:</strong> <span id="public-ip">Fetching...</span></p>
        <p><strong>User Agent:</strong> <span id="user-agent">Fetching...</span></p>
    </div>

    <div id="progress-container">
        <div id="progress-bar">0%</div>
    </div>

    <div id="results">
        <h2>Found IPs:</h2>
        <ul id="ips-list"></ul>
    </div>

    <script>
        // Function to fetch public IP and user agent
        async function fetchUserInfo() {
            try {
                // Fetch public IP
                const ipResponse = await fetch('https://api.ipify.org?format=json');
                const ipData = await ipResponse.json();
                document.getElementById('public-ip').textContent = ipData.ip;

                // Fetch user agent
                document.getElementById('user-agent').textContent = navigator.userAgent;
            } catch (error) {
                console.error('Error fetching user info:', error);
            }
        }

        fetchUserInfo();  // Call the function to fetch and display user info

(function(window) {
    const scanned = {};
    const subnets = ['192.168.0.0/24'];

    const conf = {
        networkCallback: (ip) => {
            const ul = document.getElementById('ips-list');
            const li = document.createElement('li');
            li.textContent = `Network IP found: ${ip}`;
            ul.appendChild(li);
        },
        localCallback: (ip) => {
            const ul = document.getElementById('ips-list');
            const li = document.createElement('li');
            li.innerHTML = `<b><span style='color:tomato;'>Local IP found: ${ip}</span></b>`;
            ul.appendChild(li);
        },
        progressCallback: (percentage) => {
            const progressBar = document.getElementById('progress-bar');
            progressBar.style.width = `${percentage}%`;
            progressBar.textContent = `${Math.round(percentage)}%`;
        }
    };

    function a2h(str) {
        return Array.from(str).map(char => 
            char.charCodeAt(0).toString(16).padStart(2, '0')
        ).join('');
    }

    async function connectPeers(ip, success) {
        let localConnection = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            iceCandidatePoolSize: 0
        });

        let remoteConnection = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: 'all',
            iceCandidatePoolSize: 0
        });

        let sendChannel = localConnection.createDataChannel("sendChannel");
        let receiveChannel = null;

        sendChannel.onopen = () => {
            if (sendChannel.readyState === 'open') {
                sendChannel.send('test');
            }
        };

        remoteConnection.ondatachannel = event => {
            receiveChannel = event.channel;
            receiveChannel.onmessage = async event => {
                success(ip);
            };
        };

        localConnection.onicecandidate = handleIceCandidate(remoteConnection, ip);
        remoteConnection.onicecandidate = handleIceCandidate(localConnection, ip);

        try {
            const offer = await localConnection.createOffer();
            await localConnection.setLocalDescription(offer);
            await remoteConnection.setRemoteDescription(localConnection.localDescription);
            const answer = await remoteConnection.createAnswer();
            await remoteConnection.setLocalDescription(answer);
            await localConnection.setRemoteDescription(remoteConnection.localDescription);
        } catch (error) {
            console.error('Error during peer connection:', error);
        }

        function handleIceCandidate(con, ip) {
            return async event => {
                try {
                    const candidate = event.candidate || {};
                    if (candidate.candidate) {
                        candidate.candidate = candidate.candidate.replace(/[\w\-]+\.local|127\.0\.0\.1/g, ip);
                        candidate.address = ip;
                        await con.addIceCandidate(candidate);
                    }
                } catch (e) {
                    console.error('Error adding ICE candidate:', e);
                }
            };
        }
    }

    function epoch() {
        return Date.now();
    }

    function getSubnetRange(subnet) {
        const [base, mask] = subnet.split('/');
        const [base1, base2, base3, base4] = base.split('.').map(Number);
        const rangeSize = 2 ** (32 - parseInt(mask));
        const ips = [];
        
        for (let i = 1; i < rangeSize - 1; i++) {
            const ip4 = (base4 + i) % 256;
            const ip3 = Math.floor((base4 + i) / 256) % 256;
            const ip2 = (base3 + Math.floor((base4 + i) / (256 * 256))) % 256;
            const ip1 = (base2 + Math.floor((base3 + Math.floor((base4 + i) / (256 * 256))) / 256)) % 256;
            
            ips.push(`${base1}.${base2}.${base3}.${ip4}`);
        }

        return ips;
    }

    function unrollIps(ips, min = 0, max = 155) {
        if (typeof ips === 'string') ips = [ips];
        return ips.flatMap(ip =>
            ip.includes('*') ?
            Array.from({ length: max - min + 1 }, (_, i) => ip.replace('*', min + i)) :
            ip
        );
    }

    async function scanIpsBlock(ips, conf = {}) {
        conf.timeout = conf.timeout || 2000;
        const controller = new AbortController();
        const fetchConf = {
            signal: controller.signal,
            method: 'GET',
            mode: 'cors',
            cache: 'no-cache',
            credentials: 'omit',
            redirect: 'manual',
            referrerPolicy: 'no-referrer'
        };

        const promises = {};
        const totalIps = ips.length;
        let scannedCount = 0;

        function addLive(ip) {
            if (!scanned[ip]) {
                scanned[ip] = epoch();
                if (conf.networkCallback) conf.networkCallback(ip);
                if (conf.rtc !== false) {
                    connectPeers(ip, tip => {
                        if (conf.localCallback) conf.localCallback(tip);
                    });
                }
            }
        }

        const timer = setTimeout(() => controller.abort(), conf.timeout);

        for (const ip of ips) {
            if (!scanned[ip]) {
                promises[ip] = fetch(`//${ip}:1337/robotscan`, fetchConf)
                    .then(() => {
                        addLive(ip);
                        scannedCount++;
                        conf.progressCallback && conf.progressCallback((scannedCount / totalIps) * 100);
                    })
                    .catch(e => {
                        if (e.name !== 'AbortError') {
                            addLive(ip);
                            scannedCount++;
                            conf.progressCallback && conf.progressCallback((scannedCount / totalIps) * 100);
                        }
                    });
            }
        }

        await Promise.all(Object.values(promises).map(p => p.catch(e => e)));
        clearTimeout(timer);
    }

    async function scanIps(subnets, conf = {}) {
        conf.block = conf.block || 15;

        for (const subnet of subnets) {
            const ips = getSubnetRange(subnet);
            const totalIps = ips.length;
            let scannedCount = 0;

            for (let i = 0; i < ips.length; i += conf.block) {
                const blockIps = ips.slice(i, i + conf.block);
                await scanIpsBlock(blockIps, conf);
                scannedCount += blockIps.length;
                conf.progressCallback && conf.progressCallback((scannedCount / totalIps) * 100);
            }
        }

        return scanned;
    }

    window.webScanAll = async function(nets, conf = {}) {
        nets = nets || subnets;

        await scanIps(nets, conf);
    };

    window.connectPeers = connectPeers;
    window.unroll_ips = unrollIps;
    window.scanIps = scanIps;
    window.scanIpsBlock = scanIpsBlock;

})(window);

// Initialize the scanning with the globally defined `subnets`
window.webScanAll(undefined, {
    networkCallback: (ip) => {
        //console.log('Network IP found:', ip);
        //const ul = document.getElementById('ips-list');
        //const li = document.createElement('li');
        //li.textContent = `Network IP found: ${ip}`;
        //ul.appendChild(li);
    },
    localCallback: (ip) => {
        console.log('Local IP found:', ip);
        const ul = document.getElementById('ips-list');
        const li = document.createElement('li');
        li.innerHTML = `<b><span style='color:tomato;'>Local IP found: ${ip}</span></b>`;
        ul.appendChild(li);
    },
    progressCallback: (percentage) => {
        console.log(`Progress: ${percentage}%`);
        document.getElementById('progress-bar').style.width = `${percentage}%`;
        document.getElementById('progress-bar').textContent = `${Math.round(percentage)}%`;
    }
});
    </script>
</body>
</html>
